# Analyzers-Generators CI/CD Pipeline
# Roslyn analyzers and source generators

trigger:
  branches:
    include:
    - master
    - develop
    - experimental/*
    - beta/*
    - release/*
    - feature/*
  paths:
    exclude:
    - README.md
    - docs/*
    - samples/*

pr:
  branches:
    include:
    - master
    - main
    - develop

parameters:
- name: forceProduction
  displayName: 'Force production release'
  type: boolean
  default: false

- name: runAnalyzerTests
  displayName: 'Run extended analyzer tests'
  type: boolean
  default: true

variables:
  # Base configuration
  targetFeed: 'dotnet-packages'
  dotnetVersion: '10.x'
  NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages
  
  # Configuration-specific settings
  ${{ if startsWith(variables['Build.SourceBranch'], 'refs/heads/experimental/') }}:
    buildConfiguration: 'Experimental'
    continueOnTestFailure: true
    publishTestResults: true
    failOnTestErrors: false
    runCodeCoverage: true
    runSecurityScans: false
    coverageThreshold: 0
    
  ${{ elseif eq(variables['Build.SourceBranch'], 'refs/heads/develop') }}:
    buildConfiguration: 'Alpha'
    continueOnTestFailure: true
    publishTestResults: true
    failOnTestErrors: false
    runCodeCoverage: true
    runSecurityScans: true
    coverageThreshold: 0
    
  ${{ elseif startsWith(variables['Build.SourceBranch'], 'refs/heads/beta/') }}:
    buildConfiguration: 'Beta'
    continueOnTestFailure: false
    publishTestResults: true
    failOnTestErrors: true
    runCodeCoverage: true
    runSecurityScans: true
    coverageThreshold: 70
    
  ${{ elseif startsWith(variables['Build.SourceBranch'], 'refs/heads/release/') }}:
    buildConfiguration: 'Preview'
    continueOnTestFailure: false
    publishTestResults: true
    failOnTestErrors: true
    runCodeCoverage: true
    runSecurityScans: true
    coverageThreshold: 85
    
  ${{ elseif eq(variables['Build.SourceBranch'], 'refs/heads/master') }}:
    buildConfiguration: 'Release'
    continueOnTestFailure: false
    publishTestResults: true
    failOnTestErrors: true
    runCodeCoverage: true
    runSecurityScans: true
    coverageThreshold: 90
    
  ${{ else }}:
    buildConfiguration: 'Debug'
    continueOnTestFailure: true
    publishTestResults: true
    failOnTestErrors: false
    runCodeCoverage: true
    runSecurityScans: false
    coverageThreshold: 0

stages:
- stage: Validate
  displayName: 'Validation Stage'
  jobs:
  - job: ValidateBuild
    displayName: 'Validate Build Context'
    pool:
      vmImage: 'windows-latest'
    steps:
    - script: |
        echo Build branch: $(Build.SourceBranch)
        echo Build configuration: $(buildConfiguration)
      displayName: 'Display build context'

- stage: Build
  displayName: 'Build Stage'
  dependsOn: Validate
  jobs:
  - job: BuildAnalyzers
    displayName: 'Build Analyzers & Generators'
    pool:
      vmImage: 'windows-latest'
    steps:
    - checkout: self
      fetchDepth: 0
      displayName: 'Checkout with full history'
      
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        version: $(dotnetVersion)
        includePreviewVersions: true
    
    # Cache NuGet packages
    - task: Cache@2
      displayName: 'Cache NuGet packages'
      inputs:
        key: 'nuget | "$(Agent.OS)" | **/Directory.Packages.props'
        restoreKeys: |
          nuget | "$(Agent.OS)"
        path: $(NUGET_PACKAGES)
    
    # Let Nerdbank.GitVersioning set the version variables
    - script: nbgv cloud -a
      displayName: 'Set version variables'

    - task: DotNetCoreCLI@2
      displayName: 'Install ReportGenerator'
      inputs:
        command: 'custom'
        custom: 'tool'
        arguments: 'install -g dotnet-reportgenerator-globaltool'

    # Authenticate with Azure Artifacts feeds
    - task: NuGetAuthenticate@1
      displayName: 'Authenticate with NuGet feeds'

    - task: DotNetCoreCLI@2
      displayName: 'Restore packages'
      inputs:
        command: 'restore'
        projects: '**/*.csproj'
        feedsToUse: 'config'
        nugetConfigPath: 'nuget.config'
        arguments: '--packages $(NUGET_PACKAGES)'

    - task: DotNetCoreCLI@2
      displayName: 'Build analyzers'
      inputs:
        command: 'build'
        projects: '**/*.csproj'
        arguments: >-
          --configuration $(buildConfiguration)
          --no-restore
          -p:ContinuousIntegrationBuild=true

    # Run unit tests
    - task: DotNetCoreCLI@2
      displayName: 'Run unit tests with coverage'
      inputs:
        command: 'test'
        projects: '**/*Tests.csproj'
        arguments: >-
          --configuration $(buildConfiguration)
          --no-build
          --collect:"XPlat Code Coverage"
          --settings coverlet.runsettings
          --filter "Category!=Integration"
          --logger trx
          --results-directory $(Agent.TempDirectory)
        publishTestResults: false
      ${{ if or(eq(variables['Build.SourceBranch'], 'refs/heads/develop'), startsWith(variables['Build.SourceBranch'], 'refs/heads/experimental/')) }}:
        continueOnError: true
      ${{ else }}:
        continueOnError: false

    # Run analyzer tests (testing the analyzers themselves)
    - ${{ if eq(parameters.runAnalyzerTests, true) }}:
      - task: DotNetCoreCLI@2
        displayName: 'Run analyzer integration tests'
        inputs:
          command: 'test'
          projects: '**/*Tests.csproj'
          arguments: >-
            --configuration $(buildConfiguration)
            --no-build
            --logger trx
            --results-directory $(Agent.TempDirectory)
            --filter "Category=Integration"
        ${{ if or(eq(variables['Build.SourceBranch'], 'refs/heads/develop'), startsWith(variables['Build.SourceBranch'], 'refs/heads/experimental/')) }}:
          continueOnError: true
        ${{ else }}:
          continueOnError: false

    - task: PublishTestResults@2
      displayName: 'Publish test results'
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/*.trx'
        searchFolder: '$(Agent.TempDirectory)'
        failTaskOnFailedTests: $(failOnTestErrors)
        testRunTitle: 'Analyzer Tests - $(Build.BuildNumber)'
      condition: and(succeededOrFailed(), eq(variables['publishTestResults'], 'true'))

    - script: |
        reportgenerator -reports:$(Agent.TempDirectory)/**/coverage.cobertura.xml -targetdir:$(Agent.TempDirectory)/CodeCoverage -reporttypes:"Cobertura;HtmlInline_AzurePipelines;Badges"
      displayName: 'Generate coverage report'
      condition: and(succeededOrFailed(), eq(variables['runCodeCoverage'], 'true'))

    - task: PublishCodeCoverageResults@2
      displayName: 'Publish code coverage'
      inputs:
        summaryFileLocation: '$(Agent.TempDirectory)/CodeCoverage/Cobertura.xml'
        pathToSources: '$(Build.SourcesDirectory)'
      condition: and(succeededOrFailed(), eq(variables['runCodeCoverage'], 'true'))

    # Special packaging for analyzers
    - task: DotNetCoreCLI@2
      displayName: 'Pack analyzer packages'
      inputs:
        command: 'pack'
        packagesToPack: '**/!(*Tests).csproj'
        packDirectory: '$(Build.ArtifactStagingDirectory)/packages'
        nobuild: true
        arguments: >-
          --configuration $(buildConfiguration)
          -p:RepositoryUrl=$(Build.Repository.Uri)
          -p:RepositoryBranch=$(Build.SourceBranchName)
          -p:RepositoryCommit=$(Build.SourceVersion)
          -p:DevelopmentDependency=true
          -p:IncludeBuildOutput=false

    - publish: '$(Build.ArtifactStagingDirectory)/packages'
      artifact: 'packages'
      displayName: 'Publish packages artifact'

    # Publish coverage badges
    - task: PowerShell@2
      displayName: 'Check for coverage badges'
      inputs:
        targetType: 'inline'
        script: |
          $badgePath = "$(Agent.TempDirectory)\CodeCoverage"
          if (Test-Path "$badgePath\badge_*.svg") {
            Write-Host "##vso[task.setvariable variable=BadgesExist]true"
            Write-Host "Coverage badges found"
          } else {
            Write-Host "##vso[task.setvariable variable=BadgesExist]false"
            Write-Host "No coverage badges found in $badgePath"
          }
      condition: and(succeededOrFailed(), eq(variables['runCodeCoverage'], 'true'))
    
    - publish: '$(Agent.TempDirectory)/CodeCoverage'
      artifact: 'coverage-badges'
      displayName: 'Publish coverage badges'
      condition: and(succeededOrFailed(), eq(variables['BadgesExist'], 'true'))

# Analyzer validation stage removed - NuGetPackageExplorer is not a standard tool
# - stage: AnalyzerValidation
#   displayName: 'Analyzer Validation'
#   dependsOn: Build
#   jobs:
#   - job: ValidateAnalyzers
#     displayName: 'Validate Analyzer Packages'
#     pool:
#       vmImage: 'windows-latest'
#     steps:
#     - download: current
#       artifact: 'packages'
# 
#     - task: DotNetCoreCLI@2
#       displayName: 'Install NuGet Package Explorer'
#       inputs:
#         command: 'custom'
#         custom: 'tool'
#         arguments: 'install -g NuGetPackageExplorer'
# 
#     - script: |
#         echo "Validating analyzer package structure..."
#         for %%f in ($(Pipeline.Workspace)\packages\*.nupkg) do (
#           echo Checking %%f
#           nuget-pe %%f -v
#         )
#       displayName: 'Validate package structure'

- stage: SecurityScan
  displayName: 'Security & Quality'
  dependsOn: 
  - Validate
  condition: and(succeeded(), eq(variables['runSecurityScans'], 'true'))
  jobs:
  - job: RunSecurityScans
    displayName: 'Security Scanning'
    pool:
      vmImage: 'windows-latest'
    steps:
    - checkout: self
      fetchDepth: 0
      displayName: 'Checkout with full history'
      
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        version: $(dotnetVersion)
        includePreviewVersions: true
    
    # Cache NuGet packages
    - task: Cache@2
      displayName: 'Cache NuGet packages'
      inputs:
        key: 'nuget | "$(Agent.OS)" | **/Directory.Packages.props'
        restoreKeys: |
          nuget | "$(Agent.OS)"
        path: $(NUGET_PACKAGES)

    # Authenticate with Azure Artifacts feeds
    - task: NuGetAuthenticate@1
      displayName: 'Authenticate with NuGet feeds'

    # GitHub Advanced Security tasks
    - task: AdvancedSecurity-Codeql-Init@1
      displayName: 'Initialize CodeQL'
      inputs:
        languages: 'csharp'
        
    # Restore packages for CodeQL build
    - task: DotNetCoreCLI@2
      displayName: 'Restore packages for CodeQL'
      inputs:
        command: 'restore'
        projects: '**/*.csproj'
        feedsToUse: 'config'
        nugetConfigPath: 'nuget.config'
        arguments: '--packages $(NUGET_PACKAGES)'
    
    # Build for CodeQL analysis
    - task: DotNetCoreCLI@2
      displayName: 'Build for CodeQL'
      inputs:
        command: 'build'
        projects: '**/*.csproj'
        arguments: '--configuration $(buildConfiguration) --no-restore'
    
    - task: AdvancedSecurity-Codeql-Analyze@1
      displayName: 'Perform CodeQL Analysis'
      
    # Dependency scanning
    - task: AdvancedSecurity-Dependency-Scanning@1
      displayName: 'Dependency Scanning'
      
    # Check for vulnerable packages
    - task: DotNetCoreCLI@2
      displayName: 'Security audit'
      inputs:
        command: 'custom'
        custom: 'list'
        arguments: 'package --vulnerable --include-transitive'
        feedsToUse: 'config'
        nugetConfigPath: 'nuget.config'

    # Code quality gates
    # TODO: Install BuildQualityChecks extension from marketplace
    # - task: BuildQualityChecks@9
    #   displayName: 'Check coverage threshold ($(coverageThreshold)%)'
    #   condition: gt(variables['coverageThreshold'], 0)
    #   inputs:
    #     checkCoverage: true
    #     coverageFailOption: 'fixed'
    #     coverageThreshold: '$(coverageThreshold)'
    #     coverageType: 'lines'
    #     includePartiallySucceeded: false

- stage: PublishPackages
  displayName: 'Publish Packages'
  dependsOn: 
  - Build
  - SecurityScan
  condition: |
    and(
      not(eq(variables['Build.Reason'], 'PullRequest')),
      or(
        and(succeeded('Build'), eq(variables['runSecurityScans'], 'false')),
        and(succeeded('Build'), succeeded('SecurityScan'), eq(variables['runSecurityScans'], 'true'))
      )
    )
  jobs:
  - job: PublishToFeed
    displayName: 'Publish to NuGet Feed'
    pool:
      vmImage: 'windows-latest'
    steps:
    - download: current
      artifact: 'packages'
      displayName: 'Download packages'

    # Authenticate with Azure Artifacts feeds
    - task: NuGetAuthenticate@1
      displayName: 'Authenticate with NuGet feeds'

    - task: DotNetCoreCLI@2
      displayName: 'Push packages to feed'
      inputs:
        command: 'push'
        packagesToPush: '$(Pipeline.Workspace)/packages/*.nupkg'
        nuGetFeedType: 'internal'
        publishVstsFeed: 'dotnet-packages'
        allowPackageConflicts: true

    # Tag the release (conditional)
    - checkout: self
      fetchDepth: 0
      displayName: 'Checkout with full history'  
      persistCredentials: true
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
      
    - script: |
        git config user.email "azure-pipeline@rayburnelectric.com"
        git config user.name "Azure Pipeline"
        git tag -a analyzer-v$(NBGV_SemVer2) -m "Release v$(NBGV_SemVer2)"
        git push origin analyzer-v$(NBGV_SemVer2)
      displayName: 'Tag release'
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))

# Report generation stage
- stage: Reports
  displayName: 'Generate Reports'
  dependsOn: PublishPackages
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  jobs:
  - job: GenerateReports
    displayName: 'Generate Release Reports'
    pool:
      vmImage: 'windows-latest'
    steps:
    - download: current
      artifact: 'coverage-badges'
      continueOnError: true

    - script: |
        echo "# Analyzer Release Report" > release-report.md
        echo "Version: $(NBGV_SemVer2)" >> release-report.md
        echo "Build: $(Build.BuildNumber)" >> release-report.md
        echo "" >> release-report.md
        echo "## Coverage" >> release-report.md
        if exist "$(Pipeline.Workspace)\coverage-badges\badge_combined.svg" (
          echo "![Coverage](coverage-badges/badge_combined.svg)" >> release-report.md
        ) else (
          echo "Coverage data not available" >> release-report.md
        )
      displayName: 'Generate release report'

    - publish: 'release-report.md'
      artifact: 'release-report'
      displayName: 'Publish release report'
