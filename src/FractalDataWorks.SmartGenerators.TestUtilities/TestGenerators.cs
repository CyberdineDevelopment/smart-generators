using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FractalDataWorks.SmartGenerators.TestUtilities;

#pragma warning disable CA1034 // Nested types should not be visible - Acceptable in test utilities

/// <summary>
/// Contains test generators used in tests.
/// </summary>
public static class TestGenerators
{
    /// <summary>
    /// A simple mock generator that generates code for classes with the [GenerateCode] attribute.
    /// </summary>
    [Generator]
    public class MockGenerator : IIncrementalGenerator
    {
        private readonly string _attributeSource;

        /// <summary>
        /// Initializes a new instance of the <see cref="MockGenerator"/> class.
        /// </summary>
        /// <param name="attributeSource">The source code for the GenerateCode attribute.</param>
        public MockGenerator(string attributeSource)
        {
            _attributeSource = attributeSource;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MockGenerator"/> class with default attribute source.
        /// </summary>
        public MockGenerator()
            : this(DefaultAttributeSource)
        {
        }

        /// <summary>
        /// Gets the default source for the GenerateCode attribute.
        /// </summary>
        public static string DefaultAttributeSource => @"
using System;

namespace TestNamespace
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class GenerateCodeAttribute : Attribute
    {
    }
}";

        /// <inheritdoc/>
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Register attribute
            context.RegisterPostInitializationOutput(ctx =>
                ctx.AddSource("GenerateCodeAttribute.g.cs", _attributeSource));

            // Set up the syntax provider for class declarations with the attribute
            var syntaxProvider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (syntax, _) => syntax is ClassDeclarationSyntax,
                    transform: (ctx, _) => ctx.Node as ClassDeclarationSyntax)
                .Where(node => node != null);

            // Register source output for each class
            context.RegisterSourceOutput(syntaxProvider, (ctx, classNode) =>
            {
                if (classNode == null)
                {
                    return;
                }

                // Check if the class has the attribute
                var hasAttribute = false;
                foreach (var attrList in classNode.AttributeLists)
                {
                    if (attrList.Attributes.Any(attr => attr.Name.ToString().Contains("GenerateCode")))
                    {
                        hasAttribute = true;
                    }

                    if (hasAttribute)
                    {
                        break;
                    }
                }

                if (!hasAttribute)
                {
                    return;
                }

                // Generate a new class with extra functionality
                var className = classNode.Identifier.Text;
                var namespaceName = GetContainingNamespace(classNode);

                var code = GenerateClassCode(className, namespaceName);
                ctx.AddSource($"{className}Generated.g.cs", code);
            });
        }

        private static string GetContainingNamespace(ClassDeclarationSyntax classNode)
        {
            // Find the namespace declaration
            var parent = classNode.Parent;
            while (parent != null &&
                parent is not NamespaceDeclarationSyntax &&
                parent is not FileScopedNamespaceDeclarationSyntax)
            {
                parent = parent.Parent;
            }

            return parent switch
            {
                NamespaceDeclarationSyntax nsDecl => nsDecl.Name.ToString(),
                FileScopedNamespaceDeclarationSyntax fsNsDecl => fsNsDecl.Name.ToString(),
                _ => "DefaultNamespace",
            };
        }

        private static string GenerateClassCode(string className, string namespaceName)
        {
            return $$"""
					// <auto-generated/>
					
					using System;
					
					namespace {{namespaceName}}
					{
					    /// <summary>
					    /// Generated implementation of {{className}}.
					    /// </summary>
					    public class {{className}}Generated
					    {
					        private readonly {{className}} _source;
					        
					        /// <summary>
					        /// Initializes a new instance of the <see cref="{{className}}Generated"/> class.
					        /// </summary>
					        /// <param name="source">The source instance.</param>
					        public {{className}}Generated({{className}} source)
					        {
							    _source = source ?? throw new ArgumentNullException(nameof(source));
					        }
					        
					        /// <summary>
					        /// Returns a string representation of the object.
					        /// </summary>
					        /// <returns>A string representation of the object.</returns>
					        public override string ToString()
					        {
							    return $"Generated wrapper for {_source}";
					        }
					    }
					}
					""";
        }
    }

    /// <summary>
    /// Test source generator that reports diagnostics.
    /// </summary>
    [Generator]
    public class DiagnosticGenerator : IIncrementalGenerator
    {
        private readonly DiagnosticDescriptor _missingAttributeError;
        private readonly string _attributeName;

        /// <summary>
        /// Initializes a new instance of the <see cref="DiagnosticGenerator"/> class.
        /// </summary>
        /// <param name="diagnosticId">The diagnostic ID.</param>
        /// <param name="title">The diagnostic title.</param>
        /// <param name="messageFormat">The diagnostic message format.</param>
        /// <param name="category">The diagnostic category.</param>
        /// <param name="attributeName">The name of the attribute to check for.</param>
        public DiagnosticGenerator(
            string diagnosticId = "TEST001",
            string title = "Missing Required Attribute",
            string messageFormat = "Class {0} is missing the required attribute",
            string category = "TestGenerator",
            string attributeName = "GenerateCode")
        {
            _missingAttributeError = DiagnosticReporter.CreateError(
                diagnosticId,
                title,
                messageFormat,
                category);
            _attributeName = attributeName;
        }

        /// <inheritdoc/>
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (node, _) => node is ClassDeclarationSyntax,
                    transform: (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
                .Where(node => node != null);

            context.RegisterSourceOutput(classDeclarations, (ctx, classNode) =>
            {
                if (classNode == null)
                {
                    return;
                }

                var className = classNode.Identifier.Text;
                var hasAttribute = false;

                foreach (var attrList in classNode.AttributeLists)
                {
                    foreach (var attr in attrList.Attributes)
                    {
                        if (attr.Name.ToString().Contains(_attributeName))
                        {
                            hasAttribute = true;
                            break;
                        }
                    }

                    if (hasAttribute)
                    {
                        break;
                    }
                }

                if (!hasAttribute)
                {
                    // Report diagnostic for missing attribute
                    ctx.ReportDiagnostic(Diagnostic.Create(
                        _missingAttributeError,
                        classNode.GetLocation(),
                        className));
                }
            });

            var classSyntaxProvider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (node, _) => node is ClassDeclarationSyntax,
                    transform: (ctx, _) => ctx.Node as ClassDeclarationSyntax)
                .Where(node => node != null);

            context.RegisterSourceOutput(classSyntaxProvider, (ctx, classNode) =>
            {
                if (classNode == null)
                {
                    return;
                }

                var className = classNode.Identifier.Text;
                var namespaceName = GetContainingNamespace(classNode);

                var source = $$"""

							   namespace {{namespaceName}};

							   public interface I{{className}}
							   {
							       void DoSomething();
							   }
							   """;

                ctx.AddSource($"I{className}.g.cs", source);
            });
        }

        private static string GetContainingNamespace(ClassDeclarationSyntax classNode)
        {
            // Find the namespace declaration
            var parent = classNode.Parent;
            while (parent != null &&
                parent is not NamespaceDeclarationSyntax &&
                parent is not FileScopedNamespaceDeclarationSyntax)
            {
                parent = parent.Parent;
            }

            if (parent is NamespaceDeclarationSyntax nsDecl)
            {
                return nsDecl.Name.ToString();
            }
            else if (parent is FileScopedNamespaceDeclarationSyntax fsNsDecl)
            {
                return fsNsDecl.Name.ToString();
            }

            return "DefaultNamespace";
        }
    }

    /// <summary>
    /// Generator that creates Equals/GetHashCode implementations for marked classes.
    /// </summary>
    [Generator]
    public class EqualsGenerator : IIncrementalGenerator
    {
        private readonly string _attributeSource;
        private readonly string _attributeName;

        /// <summary>
        /// Initializes a new instance of the <see cref="EqualsGenerator"/> class.
        /// </summary>
        /// <param name="attributeSource">The source code for the GenerateEquals attribute.</param>
        /// <param name="attributeName">The name of the attribute to look for.</param>
        public EqualsGenerator(string attributeSource, string attributeName = "GenerateEquals")
        {
            _attributeSource = attributeSource;
            _attributeName = attributeName;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EqualsGenerator"/> class with default attribute source.
        /// </summary>
        public EqualsGenerator()
            : this(DefaultAttributeSource)
        {
        }

        /// <summary>
        /// Gets the default source for the GenerateEquals attribute.
        /// </summary>
        public static string DefaultAttributeSource => @"
using System;

namespace TestNamespace
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class GenerateEqualsAttribute : Attribute
    {
    }
}";

        /// <inheritdoc/>
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Register post-initialization output for the attribute
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("GenerateEqualsAttribute.g.cs", _attributeSource);
            });

            // Set up syntax provider for class declarations
            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (node, _) => node is ClassDeclarationSyntax,
                    transform: (ctx, _) =>
                    {
                        // Extract class and check if it has the attribute
                        var classNode = (ClassDeclarationSyntax)ctx.Node;
                        var hasAttr = false;

                        foreach (var attrList in classNode.AttributeLists)
                        {
                            foreach (var attr in attrList.Attributes)
                            {
                                if (attr.Name.ToString().Contains(_attributeName))
                                {
                                    hasAttr = true;
                                    break;
                                }
                            }

                            if (hasAttr)
                            {
                                break;
                            }
                        }

                        return hasAttr ? classNode : null;
                    })
                .Where(node => node != null);

            // Register source output
            context.RegisterSourceOutput(classDeclarations, (ctx, classNode) =>
            {
                if (classNode == null)
                {
                    return;
                }

                var className = classNode.Identifier.Text;
                var namespaceName = GetContainingNamespace(classNode);

                // Get all properties
                var properties = new List<string>();
                foreach (var member in classNode.Members)
                {
                    if (member is PropertyDeclarationSyntax property)
                    {
                        var propertyType = property.Type.ToString();
                        var propertyName = property.Identifier.Text;

                        // Only include properties with getters
                        if (property.AccessorList != null &&
                            property.AccessorList.Accessors.Any(accessor => accessor.Kind() == SyntaxKind.GetAccessorDeclaration))
                        {
                            properties.Add(propertyName);
                        }
                    }
                }

                var code = GenerateEqualsImplementation(className, namespaceName, properties);
                ctx.AddSource($"{className}.Equals.g.cs", code);
            });
        }

        private static string GetContainingNamespace(ClassDeclarationSyntax classNode)
        {
            // Find the namespace declaration
            var parent = classNode.Parent;
            while (parent != null &&
                parent is not NamespaceDeclarationSyntax &&
                parent is not FileScopedNamespaceDeclarationSyntax)
            {
                parent = parent.Parent;
            }

            if (parent is NamespaceDeclarationSyntax nsDecl)
            {
                return nsDecl.Name.ToString();
            }
            else if (parent is FileScopedNamespaceDeclarationSyntax fsNsDecl)
            {
                return fsNsDecl.Name.ToString();
            }

            return "DefaultNamespace";
        }

        private static string GenerateEqualsImplementation(string className, string namespaceName, List<string> properties)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.AppendLine($"    // Generated partial class for {className}");
            sb.AppendLine($"    public partial class {className}");
            sb.AppendLine("    {");

            // Override Equals(object)
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Determines whether the specified object is equal to the current object.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        /// <param name=\"obj\">The object to compare with the current object.</param>");
            sb.AppendLine("        /// <returns>true if the specified object is equal to the current object; otherwise, false.</returns>");
            sb.AppendLine("        public override bool Equals(object obj)");
            sb.AppendLine("        {");
            sb.AppendLine($"            return obj is {className} other && Equals(other);");
            sb.AppendLine("        }");
            sb.AppendLine();

            // Equals(T)
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Indicates whether the current object is equal to another object of the same type.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine($"        /// <param name=\"other\">An object to compare with this object.</param>");
            sb.AppendLine("        /// <returns>true if the current object is equal to the other parameter; otherwise, false.</returns>");
            sb.AppendLine($"        public bool Equals({className} other)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (other is null) return false;");
            sb.AppendLine("            if (ReferenceEquals(this, other)) return true;");
            sb.AppendLine();

            if (properties.Count > 0)
            {
                sb.AppendLine("            return ");
                for (var i = 0; i < properties.Count; i++)
                {
                    var prop = properties[i];
                    if (i > 0)
                    {
                        sb.AppendLine(" && ");
                    }

                    sb.Append($"                EqualityComparer<object>.Default.Equals({prop}, other.{prop})");
                }

                sb.AppendLine(";");
            }
            else
            {
                sb.AppendLine("            return true; // No properties to compare");
            }

            sb.AppendLine("        }");
            sb.AppendLine();

            // GetHashCode
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Returns a hash code for the current object.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        /// <returns>A hash code for the current object.</returns>");
            sb.AppendLine("        public override int GetHashCode()");
            sb.AppendLine("        {");

            if (properties.Count > 0)
            {
                sb.AppendLine("            var hashCode = new HashCode();");
                foreach (var prop in properties)
                {
                    sb.AppendLine($"            hashCode.Add({prop});");
                }

                sb.AppendLine("            return hashCode.ToHashCode();");
            }
            else
            {
                sb.AppendLine("            return base.GetHashCode();");
            }

            sb.AppendLine("        }");

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }
    }
}
